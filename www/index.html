<html>
<head>
<title>SezPoz</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>
<p>
SezPoz is a lightweight and simple-to-learn library that lets you perform modular service lookups.
It provides some of the same capabilities as (for example) <code>java.util.ServiceLoader</code>, Eclipse extension points, and NetBeans <code>Lookup</code> and XML layers.
However, SezPoz has some special advantages:
</p>
<ol>
  <li>
      <p>
      The service registrations are made just using type-checked Java annotations.
      There are no configuration files to edit, and your Java IDE can show you registrations since they are simply usages of an annotation.
      Currently you need to run APT (with default arguments) instead of or in addition to javac for any sources which may contain indexable items.
      (It is planned to make it possible to just use javac when you have JDK 6.)
<!--
      On JDK 6, no special build or packaging steps are required (just javac); on JDK 5, you just need to run APT (with default arguments).
-->
      Looking up services just requires that you have a <code>ClassLoader</code> which can "see" all of the "modules" (as with <code>ServiceLoader</code>).
      </p>
  </li>
  <li>
      <p>
      You can register individual objects (values of static fields or methods) instead of whole classes.
      </p>
  </li>
  <li>
      <p>
      You can associate static metadata with each implementation, using regular annotation values.
      The caller can choose to inspect the metadata without loading the actual implementation object (as with Eclipse extension points).
      </p>
  </li>
</ol>
<p>
Sources are in the form of NetBeans projects, but you can build them (and run the demo) just using Ant.
</p>
<p>
(Why the name? SezPoz "says" the "position" of your services. It is also a
"<a href="http://slovnik.seznam.cz/search.py?wd=seznam&amp;lg=cz_en">seznam</a>
<a href="http://slovnik.seznam.cz/search.py?wd=pozn%C3%A1mka&amp;lg=cz_en">pozn√°mek</a>".)
</p>
<hr>
<p>
Usage summary (see Javadoc for details on particular classes, or just look at demo sources):
<p>

Support for declaring, creating, and inspecting indices of annotated Java elements.
 <p>
 For example, to permit registration of simple menu items, while
 making it possible to prepare a menu without loading any of them
 until they are actually selected:
 <pre>
 @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
 @Indexable(type=ActionListener.class)
 public @interface MenuItem {
     String menuName();
     String itemName();
     String iconPath() default "";
 }
 </pre>
 A concrete registration might look like:
 <pre>
 @MenuItem(menuName="File", itemName="Print", iconPath=".../print.png")
 public class PrintAction extends AbstractAction {
     public void actionPerformed(ActionEvent e) {...}
 }
 </pre>
 Alternatively:
 <pre>
 public class Actions {
     @MenuItem(menuName="File", itemName="Print")
     public static Action print() {...}
 }
 </pre>
 or even:
 <pre>
 public class Actions {
     @MenuItem(menuName="File", itemName="Print")
     public static final Action PRINT = ...;
 }
 </pre>
 To create the index, simply run apt instead of/in addition to javac.
 (The processor is in the same JAR as this API and should be autodetected.)
 <p>
 Usage is then simple:
 <pre>
 for (final IndexItem&lt;MenuItem,ActionListener&gt; item : Index.load(MenuItem.class, ActionListener.class)) {
     JMenu menu = new JMenu(item.annotation().menuName());
     JMenuItem menuitem = new JMenuItem(item.annotation().itemName());
     String icon = item.annotation().iconPath();
     if (!icon.equals("")) {
          menuitem.setIcon(new ImageIcon(icon));
     }
     menuitem.addActionListener(new ActionListener() {
         public void actionPerformed(ActionEvent e) {
             try {
                 item.instance().actionPerformed(e);
             } catch (InstantiationException x) {
                 x.printStackTrace();
             }
         }
     });
 }
 </pre>

<p>
Known limitations:
</p>
<ol>
<li><p>No support yet for processing annotations automatically from JDK 6 javac.</p></li>
<li><p>Incremental compilation can result in an index file being generated with only some
of the desired entries, if other source files are omitted e.g. by Ant.
Does not appear that JSR 269 can solve this, as it does not permit a processor to build output incrementally.</p></li>
<li><p>The Java language spec currently prohibits recursive annotation definitions,
although as of this writing javac does not.
See <a href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6264216">bug #6264216</a>.</p></li>
</ol>

</body>
</html>
